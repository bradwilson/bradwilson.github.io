---
layout: default
title: Anatomy of a Prompt &raquo; Blog Posts &raquo; Brad Wilson
---

<h1>Anatomy of a Prompt</h1>
<div>First posted: 20 August 2017</div>
<div>Last updated: 30 August 2017</div>

<h2>Table of Contents</h2>

<ul>
  <li><a href="#intro">Introduction</a></li>
  <li><a href="#shell">Shell, Font, and Colors</a></li>
  <li><a href="#poshgit">posh-git</a></li>
  <li><a href="#prompt">prompt Function</a></li>
  <li><a href="#environment">Prompt Environment</a></li>
  <li><a href="#downloads">Downloadable Files</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

<h2 id="intro">Introduction</h2>

<p>Whenever I post a screen shot of my PowerShell prompt, people ask me how it's put together:</p>
<p><img class="border" src="/images/prompt/conemu.png" alt="ConEmu ScreenShot" /></p>
<p>
  There's a lot going on in this screenshot, so I'm going to put together the pieces. The
  information here assumes you have general familiarity with customing your PowerShell
  environment (for example, editing your profile file). It also assumes you have some
  pre-requisites installed, like Git for Windows and Visual Studio.
</p>
<p>
  You can copy/paste along as we go, but I have also provided downloadable versions at
  the end of the blog post.
</p>
<p><em>
  <strong>Important Note:</strong> When saving the PowerShell files, make sure they are saved as
  "UTF-8 with Signature". This will ensure that PowerShell treats your file as UTF-8 and does not
  accidentally treat it as ANSI. Here is an example using my editor of choice,
  <a href="http://www.flos-freeware.ch/notepad2.html">Notepad2</a>:
</em></p>
<p><img class="border" src="/images/prompt/encoding.png" alt="Encoding in Notepad2" /></p>

<h2 id="shell">Shell, Font, and Colors</h2>

<p>
  The first thing you'll notice is that I'm using a tabbed command window. The program I'm
  using is called <a href="https://conemu.github.io/">ConEmu</a>, and I've chosen it because
  its configuration allows me to get exactly what I want, in a portable executable. (I keep
  most of my utilities like this in the cloud, so that I can just sync them down to a new
  machine with no installation.)
</p>
<p>
  The most critical feature that I'm leveraging here is the ability of ConEmu to create a
  slightly compressed font display without needing an actual condensed font. Speaking of
  fonts, I use a font from the awesome <a href="https://github.com/ryanoasis/nerd-fonts/">Nerd
  Fonts</a> project to provide several of the custom symbols in my prompt. It joins together
  icons from several projects (including Powerline, Font Awesome, and Octicons), and creates
  pre-merged versions of their font based on several free, fixed pitch fonts (my prompt is using
  <a href="https://github.com/ryanoasis/nerd-fonts/blob/master/patched-fonts/UbuntuMono/Regular/complete/Ubuntu%20Mono%20Nerd%20Font%20Complete%20Mono%20Windows%20Compatible.ttf?raw=true">Ubuntu
  Mono</a>).
</p>
<p><img class="border" src="/images/prompt/font.png" alt="ConEmu Font Settings" /></p>
<p>
  I get the slightly condensed look with the "Width" setting (width of 9 against font size
  of 20).
</p>
<p>
  Lastly, I use a custom color set (based heavily on the Ubuntu default terminal colors).
  The colors I've chosen for many of the prompt elements are based on the mix of these custom
  colors; if you choose to stick with the default color values, you may wish to adjust some
  of my color choices for better legibility.
</p>
<p><img class="border" src="/images/prompt/colors.png" alt="ConEmu Colors" /></p>
<p><em>
  <strong>Important note:</strong> Because there are use of Unicode characters in many of the
  samples, please make sure your text editor is capable of editing files in UTF-8 mode. If you
  see <code>?</code> characters where you expect to see custom symbols, make sure that your
  file is in UTF-8 mode, and that your text editor is using your custom Nerd Font.
</em></p>
  
<h2 id="poshgit">posh-git</h2>

<p>
  The blue portion of the prompt is Git project information, powered by
  <a href="https://github.com/dahlbyk/posh-git">posh-git</a>. This is a PowerShell plugin
  that supports printing information about the Git repository referenced by the current
  directory. The great thing about posh-git is that it comes with a tremendous amount
  of flexibility when formatting the prompt output. Here is what it looks like by
  default:
</p>
<p><img class="border" src="/images/prompt/default-poshgit.png" alt="Default posh-git Prompt" /></p>
<p>
  You configure the prompt by overriding the default values in a configuration object
  that posh-git sets. Here are the overrides which convert that default prompt into
  the blue prompt you've seen above:
</p>
{% highlight powershell %}
# Background colors
$baseBackgroundColor = "DarkBlue"
$GitPromptSettings.AfterBackgroundColor = $baseBackgroundColor
$GitPromptSettings.AfterStashBackgroundColor = $baseBackgroundColor
$GitPromptSettings.BeforeBackgroundColor = $baseBackgroundColor
$GitPromptSettings.BeforeIndexBackgroundColor = $baseBackgroundColor
$GitPromptSettings.BeforeStashBackgroundColor = $baseBackgroundColor
$GitPromptSettings.BranchAheadStatusBackgroundColor = $baseBackgroundColor
$GitPromptSettings.BranchBackgroundColor = $baseBackgroundColor
$GitPromptSettings.BranchBehindAndAheadStatusBackgroundColor = $baseBackgroundColor
$GitPromptSettings.BranchBehindStatusBackgroundColor = $baseBackgroundColor
$GitPromptSettings.BranchGoneStatusBackgroundColor = $baseBackgroundColor
$GitPromptSettings.BranchIdenticalStatusToBackgroundColor = $baseBackgroundColor
$GitPromptSettings.DelimBackgroundColor = $baseBackgroundColor
$GitPromptSettings.IndexBackgroundColor = $baseBackgroundColor
$GitPromptSettings.ErrorBackgroundColor = $baseBackgroundColor
$GitPromptSettings.LocalDefaultStatusBackgroundColor = $baseBackgroundColor
$GitPromptSettings.LocalStagedStatusBackgroundColor = $baseBackgroundColor
$GitPromptSettings.LocalWorkingStatusBackgroundColor = $baseBackgroundColor
$GitPromptSettings.StashBackgroundColor = $baseBackgroundColor
$GitPromptSettings.WorkingBackgroundColor = $baseBackgroundColor

# Foreground colors
$GitPromptSettings.AfterForegroundColor = "Blue"
$GitPromptSettings.BeforeForegroundColor = "Blue"
$GitPromptSettings.BranchForegroundColor = "Blue"
$GitPromptSettings.BranchGoneStatusForegroundColor = "Blue"
$GitPromptSettings.BranchIdenticalStatusToForegroundColor = "White"
$GitPromptSettings.DefaultForegroundColor = "Gray"
$GitPromptSettings.DelimForegroundColor = "Blue"
$GitPromptSettings.IndexForegroundColor = "Green"
$GitPromptSettings.WorkingForegroundColor = "Yellow"

# Prompt shape
$GitPromptSettings.AfterText = " "
$GitPromptSettings.BeforeText = "  "
$GitPromptSettings.BranchAheadStatusSymbol = ""
$GitPromptSettings.BranchBehindStatusSymbol = ""
$GitPromptSettings.BranchBehindAndAheadStatusSymbol = ""
$GitPromptSettings.BranchGoneStatusSymbol = ""
$GitPromptSettings.BranchIdenticalStatusToSymbol = ""
$GitPromptSettings.DelimText = " ॥"
$GitPromptSettings.LocalStagedStatusSymbol = ""
$GitPromptSettings.LocalWorkingStatusSymbol = ""
$GitPromptSettings.ShowStatusWhenZero = $false
{% endhighlight %}
<p>
  To use these overrides, place these lines after the <code>Import-Module</code> statement that
  posh-git added to your PowerShell profile. Once you restart your shell, you should see your new
  customizations in place (don't worry about the path; we'll be removing that later on):
</p>
<p><img class="border" src="/images/prompt/override-poshgit.png" alt="post-git Customized Prompt" /></p>
<p>
  If you want to customize the symbols used in the prompt, the easiest way to find them is by
  using the Character Map application built into Windows. Just select the Nerd Font you're using
  while browsing characters, and you can copy them directly from this app into your profile:
</p>
<p><img class="border" src="/images/prompt/charmap.png" alt="Windows Character Map application" /></p>

<h2 id="prompt">prompt Function</h2>

<p>
  When PowerShell wants to display your prompt, it executes the command <code>prompt</code>. By default, this
  command is provided by a "PowerShell function". Adding this to your Profile will override the default
  prompt with our custom prompt (I'll break down each section afterward):
</p>

{% highlight powershell %}
set-content Function:prompt {
  $title = (get-location).Path.replace($home, "~")
  $idx = $title.IndexOf("::")
  if ($idx -gt -1) { $title = $title.Substring($idx + 2) }

  $windowsIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
  $windowsPrincipal = new-object 'System.Security.Principal.WindowsPrincipal' $windowsIdentity
  if ($windowsPrincipal.IsInRole("Administrators") -eq 1) { $color = "Red"; }
  else { $color = "Green"; }

  $Host.UI.RawUI.ForegroundColor = $GitPromptSettings.DefaultForegroundColor

  if ($LASTEXITCODE -ne 0) {
      write-host " " -NoNewLine
      write-host "  $LASTEXITCODE " -NoNewLine -BackgroundColor DarkRed -ForegroundColor Yellow
  }

  if ($PromptEnvironment -ne $null) {
      write-host " " -NoNewLine
      write-host $PromptEnvironment -NoNewLine -BackgroundColor DarkMagenta -ForegroundColor White
  }

  if (Get-GitStatus -ne $null) {
      write-host " " -NoNewLine
      Write-VcsStatus
  }

  $global:LASTEXITCODE = 0

  if ((get-location -stack).Count -gt 0) {
    write-host " " -NoNewLine
    write-host (("+" * ((get-location -stack).Count))) -NoNewLine -ForegroundColor Cyan
  }

  write-host " " -NoNewLine
  write-host "PS>" -NoNewLine -ForegroundColor $color

  $host.UI.RawUI.WindowTitle = $title
  return " "
}
{% endhighlight %}

<p>Let's break this down into the individual parts of the prompt.</p>

<h3>Path in the window title</h3>

<p>
  First, you may have noticed in my original screenshot that I don't put the current path on the prompt;
  instead, I put it into the window title. I find that keeps the prompt compact and consistent. The first
  section of my prompt function grabs the current path, and replaces your home folder with <code>~</code>,
  stashing away the value into <code>$title</code> so it can be used at the end of the prompt:
</p>
{% highlight powershell %}
$title = (get-location).Path.replace($home, "~")
$idx = $title.IndexOf("::")
if ($idx -gt -1) { $title = $title.Substring($idx + 2) }

# ...

$host.UI.RawUI.WindowTitle = $title
{% endhighlight %}

<h3>Detecting whether you're admin or not</h3>

<p>
  The second thing we do is determine whether you're running as admin or not (meaning, did your prompt
  request administrator rights via UAC). We convert this into a color, so we print the trailing
  <code>PS&lt;</code> in either green (safe, non-admin) or red (danger, admin) so you can quickly
  see whether your command prompt can get you into extra trouble:
</p>

{% highlight powershell %}
$windowsIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()
$windowsPrincipal = new-object 'System.Security.Principal.WindowsPrincipal' $windowsIdentity
if ($windowsPrincipal.IsInRole("Administrators") -eq 1) { $color = "Red"; }
else { $color = "Green"; }

# ...

write-host "PS>" -NoNewLine -ForegroundColor $color
{% endhighlight %}

<h3>Printing last exit code</h3>

<p>
  Now we're going to start printing pieces of the prompt. The first thing we're going to do is
  print out the last exit code, if there was a failure. We also clear it, so that we only end
  up printing it once (PowerShell won't clear it unless you run another external command, so
  this helps us keep the prompt clean):
</p>

{% highlight powershell %}
if ($LASTEXITCODE -ne 0) {
  write-host " " -NoNewLine
  write-host "  $LASTEXITCODE " -NoNewLine -BackgroundColor DarkRed -ForegroundColor Yellow
}

# ...

$global:LASTEXITCODE = 0
{% endhighlight %}

<h3>Printing prompt environment</h3>

<p>
  We haven't seen the use of the prompt environment in code yet, but this is where we add
  something to prompt to indicate we're in a special environment. The example shown up top
  shows a prompt for Visual Studio 2017; I'll show you the full mechanics of that command
  later, but the key part here is that the script will set a value that we look for:
</p>

{% highlight powershell %}
if ($PromptEnvironment -ne $null) {
  write-host " " -NoNewLine
  write-host $PromptEnvironment -NoNewLine -BackgroundColor DarkMagenta -ForegroundColor White
}
{% endhighlight %}

<h3>Printing Git status</h3>

<p>
  Now we'll print the status of our source control (from posh-git), if our current directory happens
  to be a Git folder:
</p>

{% highlight powershell %}
if (Get-GitStatus -ne $null) {
  write-host " " -NoNewLine
  Write-VcsStatus
}
{% endhighlight %}

<h3>Printing directory stack information</h3>

<p>
  In PowerShell (as with many other shells), you can use the <code>pushd</code> and <code>popd</code>
  commands to temporarily change your current directory, and then pop back to where you started.
  This is a stack, which means you can push arbitrary folders to be popped later. Our prompt prints
  <code>+</code> to represent the current stack depth:
</p>

{% highlight powershell %}
if ((get-location -stack).Count -gt 0) {
  write-host " " -NoNewLine
  write-host (("+" * ((get-location -stack).Count))) -NoNewLine -ForegroundColor Cyan
}
{% endhighlight %}

<p>Here is a quick screenshot of how this works:</p>
<p><img class="border" src="/images/prompt/stack.png" alt="Command Prompt Stack Depth" /></p>

<h3>Returning a string</h3>

<p>
  There is an oddity with PowerShell's expectations of the <code>prompt</code> command: it expects
  it to return a string, which it then prints. If you fail to return a string, then it will print
  <code>PS&gt;</code> for you. Since we already printed that (in our color of choice), we just
  return a single space:
</p>

{% highlight powershell %}
return " "
{% endhighlight %}

<h2 id="environment">Prompt Environment</h2>

<p>
  The final piece of the puzzle is printing the prompt environment. I have several commands which
  place the shell into a special mode to be used for specific environments. For example, I have
  a command called <code>vs2017</code> which adds Visual Studio environment variables just as
  though you'd run the Visual Studio Command Prompt, and then adds that information to the
  printed prompt environment.
</p>
<p>Here is the contents of <code>vs2017.ps1</code>:</p>

{% highlight powershell %}
param(
  [string]$edition,
  [switch]$noWeb = $false
)

if ($PromptEnvironment -ne $null) {
  write-host "error: Prompt is already in a custom environment." -ForegroundColor Red
  exit 1
}

# Try and find a version of Visual Studio in the expected location, since the VS150COMNTOOLS environment variable isn't there any more
$basePath = join-path (join-path ${env:ProgramFiles(x86)} "Microsoft Visual Studio") "2017"

if ((test-path $basePath) -eq $false) {
  write-warning "Visual Studio 2017 is not installed."
  exit 1
}

if ($edition -eq "") {
  $editions = (get-childitem $basePath | where-object { $_.PSIsContainer })
  if ($editions.Count -eq 0) {
    write-warning "Visual Studio 2017 is not installed."
    exit 1
  }
  if ($editions.Count -gt 1) {
    write-warning "Multiple editions of Visual Studio 2017 are installed. Please specify one of the editions ($($editions -join ', ')) with the -edition switch."
    exit 1
  }
  $edition = $editions[0]
}

$path = join-path (join-path (join-path $basePath $edition) "Common7") "Tools"

if ((test-path $path) -eq $false) {
  write-warning "Visual Studion 2017 $edition could not be found."
  exit 1
}

$cmdPath = join-path $path "VsDevCmd.bat"

if ((test-path $cmdPath) -eq $false) {
  write-warning "File not found: $cmdPath"
  exit 1
}

$tempFile = [IO.Path]::GetTempFileName()

cmd /c " `"$cmdPath`" && set > `"$tempFile`" "

Get-Content $tempFile | %{
  if ($_ -match "^(.*?)=(.*)$") {
    Set-Content "env:\$($matches[1])" $matches[2]
  }
}

Remove-Item $tempFile

if ($noWeb -eq $false) {
  $path = join-path (join-path (join-path $basePath $edition) "Web") "External"

  if (test-path $path) {
    $env:path = $env:path + ";" + $path
  } else {
    write-warning "Path $path not found; specify -noWeb to skip searching for web tools"
  }
}

$global:PromptEnvironment = "  2017 "
{% endhighlight %}

<p>
  This script is a little complex because Visual Studio 2017 now allows you to install multiple editions
  side by side. It looks to see which edition you have installed and uses the <code>VsDevCmd.bat</code>
  to get the updated environment variables. If you have multiple editions installed, you can use
  the <code>-edition</code> switch to specify which environment you want.
</p>
<p>
  The final line of the script sets the global <code>PromptEnvironment</code> variable, which we use
  in our custom prompt function.
</p>
<p>
  I have several of these little scripts to set up different environments. You can use this Visual Studio
  2017 script as a starting point to developing your own custom environment scripts. In the downloads below,
  I have provided versions for Visual Studio 2015, 2017, and Preview.
</p>

<h2 id="downloads">Downloadable Files</h2>

<ul>
  <li><a href="https://gist.githubusercontent.com/bradwilson/0cf1818bc9dc6c203c68d44d2f96c102/raw/bc72665599df0d559bf1a4119e0dc9d2d28acaa5/profile.ps1">profile.ps1</a></li>
  <li><a href="https://gist.github.com/bradwilson/0cf1818bc9dc6c203c68d44d2f96c102/raw/bc72665599df0d559bf1a4119e0dc9d2d28acaa5/vs2015.ps1">vs2015.ps1</a></li>
  <li><a href="https://gist.github.com/bradwilson/0cf1818bc9dc6c203c68d44d2f96c102/raw/bc72665599df0d559bf1a4119e0dc9d2d28acaa5/vs2017.ps1">vs2017.ps1</a></li>
  <li><a href="https://gist.github.com/bradwilson/0cf1818bc9dc6c203c68d44d2f96c102/raw/bc72665599df0d559bf1a4119e0dc9d2d28acaa5/vspreview.ps1">vspreview.ps1</a></li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>
  I hope this quick tour through my custom prompt inspires you to make customizations of your
  own, based on your needs. Being able to carefully craft your prompt to be succinct and
  quickly glanceable can be very handy when spending significant time in your command window
  of choice.
</p>
<p>Happy hacking!</p>
